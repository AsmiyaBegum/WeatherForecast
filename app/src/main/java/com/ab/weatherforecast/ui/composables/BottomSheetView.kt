package com.ab.weatherforecast.ui.composablesimport androidx.compose.foundation.Imageimport androidx.compose.foundation.layout.Arrangementimport androidx.compose.foundation.layout.Columnimport androidx.compose.foundation.layout.Rowimport androidx.compose.foundation.layout.fillMaxSizeimport androidx.compose.foundation.layout.fillMaxWidthimport androidx.compose.foundation.layout.paddingimport androidx.compose.foundation.layout.sizeimport androidx.compose.foundation.rememberScrollStateimport androidx.compose.foundation.verticalScrollimport androidx.compose.material3.Cardimport androidx.compose.material3.Dividerimport androidx.compose.material3.IconButtonimport androidx.compose.material3.MaterialThemeimport androidx.compose.material3.Surfaceimport androidx.compose.material3.Textimport androidx.compose.runtime.Composableimport androidx.compose.runtime.getValueimport androidx.compose.runtime.mutableStateOfimport androidx.compose.runtime.rememberimport androidx.compose.runtime.rememberUpdatedStateimport androidx.compose.runtime.setValueimport androidx.compose.ui.Alignmentimport androidx.compose.ui.Modifierimport androidx.compose.ui.graphics.Colorimport androidx.compose.ui.graphics.painter.Painterimport androidx.compose.ui.res.painterResourceimport androidx.compose.ui.res.stringResourceimport androidx.compose.ui.text.font.FontWeightimport androidx.compose.ui.text.style.TextAlignimport androidx.compose.ui.unit.dpimport androidx.compose.ui.unit.spimport androidx.hilt.navigation.compose.hiltViewModelimport androidx.navigation.NavControllerimport com.ab.weatherforecast.Rimport com.ab.weatherforecast.domain.model.WeatherInfoimport com.ab.weatherforecast.domain.model.WeatherItemimport com.ab.weatherforecast.domain.model.WeatherMetricsimport com.ab.weatherforecast.ui.mapscreen.MapScreenViewModelimport com.ab.weatherforecast.ui.weatherDetail.WeatherScreenimport com.ab.weatherforecast.utils.StringConstants.DEGREEimport com.ab.weatherforecast.utils.roundToimport com.ab.weatherforecast.utils.timeimport java.util.Calendar@Composablefun BottomContent(weatherInfo: WeatherInfo, navController: NavController, iFullScreen : Boolean, viewModel: MapScreenViewModel = hiltViewModel(),                  onClick : (WeatherInfo) -> (Unit)) {    var isClicked by remember { mutableStateOf(false) }    val bookmarkIsClicked = rememberUpdatedState(newValue = isClicked)    val painterBookmark: Painter = if (bookmarkIsClicked.value) {        painterResource(id = R.drawable.ic_bookmark_added)    } else {        painterResource(id = R.drawable.ic_add_bookmark)    }    val  painterExpand: Painter = if (iFullScreen) {        painterResource(id = R.drawable.ic_cancel)    } else {        painterResource(id = R.drawable.ic_expand)    }    val selectedDate = Calendar.getInstance()    val list = weatherInfo.weather.filter {        changeDateFormat( it.dt_txt) == formatCalendarDate(selectedDate)    }    val todayTemp = list.minBy { it.main.temp_min }.main    var temperature by remember { mutableStateOf(Pair(todayTemp.temp_min,todayTemp.temp_max)) }    var selectedDates by remember {        mutableStateOf(selectedDate)    }    var isFahrenheit by remember { mutableStateOf(false) }    Surface(        modifier = Modifier.fillMaxSize()    ) {        Column(            modifier = Modifier.fillMaxWidth()        ) {            Row(                modifier = Modifier.fillMaxWidth(),                horizontalArrangement = Arrangement.Center, // Aligns children at start and end                verticalAlignment = Alignment.CenterVertically // Aligns children vertically            ) {                Column(                    modifier = Modifier.weight(1f) // Takes up available space                ) {                    Text(                        text = weatherInfo.location?:"",                        textAlign = TextAlign.Center,                        modifier = Modifier                            .fillMaxWidth()                            .padding(vertical = 12.dp),                        fontWeight = FontWeight.ExtraBold,                        style = MaterialTheme.typography.titleLarge                    )                    Text(                        text = stringResource(                            id = R.string.lat_long_format,                            weatherInfo.lat.toDouble().roundTo(3),                            weatherInfo.long.toDouble().roundTo(3)                        ),                        textAlign = TextAlign.Center,                        modifier = Modifier                            .fillMaxWidth()                            .padding(bottom = 12.dp),                        fontWeight = FontWeight.Bold,                        style = MaterialTheme.typography.titleMedium                    )                }                IconButton(                    onClick = {                        if(!isClicked) {                            isClicked = true                            viewModel.bookmarkFavoriteLocation(weatherInfo)                        }                    },                    modifier = Modifier.padding(end = 16.dp)                ) {                    Image(                        painter = painterBookmark,                        contentDescription = stringResource(id = R.string.add_bookmark),                        modifier = Modifier.size(36.dp)                    )                }                IconButton(                    onClick = {                        if(iFullScreen) {                            navController.navigate("mapScreen"){                                popUpTo("mapScreen"){                                    inclusive = false                                }                            }                        } else {                            onClick.invoke(weatherInfo)                        }                    },                    modifier = Modifier.padding(end = 16.dp)                ) {                    Image(                        painter = painterExpand,                        contentDescription = stringResource(id = R.string.close_icon),                        modifier = Modifier.size(36.dp)                    )                }            }            Column(                modifier = Modifier                    .fillMaxWidth()                    .verticalScroll(rememberScrollState())            ) {                DayChip(weatherList = weatherInfo.weather) { temp ->                    temperature = Pair(temp.first,temp.second)                    selectedDates = temp.third                }                // Average temperature                AverageTemperature(temperature){                    isFahrenheit = it                }                if(iFullScreen){                    val date = formatCalendarDate(selectedDates)                    val weatherList  = weatherInfo.weather.filter { changeDateFormat( it.dt_txt) == date }                    val data = generateHourlyForecastData( weatherList)                    // Detail                    val weather =  weatherList[0]                    WeatherDetails(WeatherMetrics(                        humidity =weather.main.humidity.toString(),                        feelLike = weather.main.feels_like.toString(),                        pressure = weather.main.pressure.toString(),                        wind = weather.wind.speed.toString()                    ))                    HourlyForecastCard(data,isFahrenheit)                    WeatherScreen(weatherData = data,isFahrenheit)                }            }        }    }}fun generateHourlyForecastData(weatherList : List<WeatherItem>) : List<HourlyForecastData>{    val hourlyForecastData = arrayListOf<HourlyForecastData>()    weatherList.forEach { weatherItem ->        hourlyForecastData.add(            HourlyForecastData(                weatherItem.weather[0].description,                weatherItem.dt_txt.time()       ,                weatherItem.main.temp,                convertToFahrenheit(weatherItem.main.temp).roundTo(2)            )        )    }    return hourlyForecastData}@Composablefun WeatherDetails(weatherMetrics: WeatherMetrics) {    Column(        modifier = Modifier            .fillMaxWidth()            .padding(start = 16.dp, end = 16.dp)    ) {        Text(text = "Details : ")        Divider(color = Color.LightGray, thickness = 0.5.dp, modifier = Modifier            .fillMaxWidth()            .padding(top = 8.dp))        Row(modifier = Modifier.fillMaxWidth(),            horizontalArrangement = Arrangement.SpaceEvenly){            WeatherInformation(modifier = Modifier, text = "Wind", value = "${weatherMetrics.wind} Km/h")            WeatherInformation(modifier = Modifier, text = "Humidity", value = "${weatherMetrics.humidity}%")        }        Row(modifier = Modifier.fillMaxWidth(),            horizontalArrangement = Arrangement.SpaceEvenly){            WeatherInformation(modifier = Modifier, text = "Pressure", value = "${weatherMetrics.pressure} mb")            WeatherInformation(modifier = Modifier, text = "Feels like", value = "${weatherMetrics.feelLike}${DEGREE}")        }    }}@Composablefun WeatherInformation(modifier: Modifier, text : String, value : String){    Column(modifier = modifier,        horizontalAlignment = Alignment.CenterHorizontally) {        Card(            modifier = Modifier.padding(top = 10.dp)        ) {            Text(                text = text,                modifier = Modifier                    .padding(10.dp)            )        }        Text(            text = value,            modifier = Modifier.padding(top = 10.dp),            fontSize = 20.sp,            textAlign = TextAlign.Center,            fontWeight = FontWeight.Bold        )    }}